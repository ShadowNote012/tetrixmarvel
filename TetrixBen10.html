<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>shadow_trix.com</title>
  <style>
    .btn-restart {
      margin-left: 100px;
      /* Distância da margem esquerda */
    }

    #pause-screen {
      position: fixed;
      /* Fixa a tela sobre todo o conteúdo */
      top: 0;
      /* Alinha ao topo da tela */
      left: 0;
      /* Alinha à esquerda da tela */
      width: 100%;
      /* Largura total da tela */
      height: 100%;
      /* Altura total da tela */
      background: rgba(0, 0, 0, 0.6);
      /* Fundo semi-transparente */
      display: none;
      /* Inicialmente escondido */
      justify-content: center;
      /* Centraliza conteúdo verticalmente */
      align-items: center;
      /* Centraliza conteúdo horizontalmente */
      flex-direction: column;
      /* Organiza elementos em coluna */
      color: black;
      /* Cor do texto */
      font-size: 2rem;
      /* Tamanho do texto */
      z-index: 999;
      /* Sobrepõe outros elementos */
    }

    #pause-screen h2 {
      background: #deb02a;
      /* Cor de fundo do título */
      padding: 15px 66px;
      /* Espaçamento interno */
      border-radius: 15px 15px 0 0;
      /* Arredonda cantos superiores */
      margin: 0;
      /* Remove margem padrão */
    }

    .pause-buttons {
      display: flex;
      /* Ativa flexbox para os botões */
      gap: 60px;
      /* Espaço entre botões */
      background: #deb02a;
      /* Fundo da caixa de botões */
      padding: 20px;
      /* Espaço interno da caixa */
      border-radius: 0px 0px 15px 15px;
      /* Arredonda cantos inferiores */
    }

    .pause-buttons button {
      width: 70px;
      /* Largura do botão */
      height: 70px;
      /* Altura do botão */
      border: none;
      /* Remove borda padrão */
      border-radius: 50%;
      /* Torna botão circular */
      background: transparent;
      /* Fundo transparente */
      cursor: pointer;
      /* Muda cursor para mão */
      display: flex;
      /* Ativa flexbox interno */
      justify-content: center;
      /* Centraliza conteúdo horizontalmente */
      align-items: center;
      /* Centraliza conteúdo verticalmente */
      padding: 0;
      /* Remove padding interno */
    }

    .pause-buttons button img {
      width: 70px;
      /* Largura da imagem */
      height: 70px;
      /* Altura da imagem */
      pointer-events: none;
      /* Evita que clique afete a imagem */
    }

    /* NOVO: estilos para links de desenvolvedores */
    .dev-links {
      margin-top: 18px;
      background: rgba(255, 200, 28, 0.95);
      border: 4px solid #000;
      padding: 12px 18px;
      border-radius: 12px;
      display: flex;
      gap: 16px;
      flex-direction: column;
      align-items: center;
      font-weight: bold;
      color: #000;
    }
    .dev-links a {
      color: #000;
      text-decoration: none;
      border-bottom: 2px dashed rgba(0,0,0,0.15);
      padding-bottom: 2px;
      font-size: 1.1rem;
    }
    .dev-links a:hover {
      text-decoration: underline;
      transform: scale(1.02);
    }

    #custom-notification {
      position: fixed;
      /* Fixa notificação na tela */
      top: 50%;
      /* Centraliza verticalmente */
      left: 50%;
      /* Centraliza horizontalmente */
      transform: translate(-50%, -50%);
      /* Ajusta posição central */
      background: #ffc81c;
      /* Cor de fundo */
      font-weight: bold;
      /* Texto em negrito */
      color: #222;
      /* Cor do texto */
      font-size: 24px;
      /* Tamanho do texto */
      border: 6px solid #000;
      /* Borda preta */
      border-radius: 16px;
      /* Arredonda cantos */
      padding: 32px 52px;
      /* Espaçamento interno */
      box-shadow: 0 10px 40px rgba(0, 0, 0, .45);
      /* Sombra */
      z-index: 9999;
      /* Fica acima de tudo */
      display: none;
      /* Inicialmente escondido */
      text-align: center;
      /* Centraliza texto */
    }

    :root {
      --cell: 30px;
      /* Tamanho de cada célula do jogo */
      --w: calc(var(--cell) * 10);
      /* Largura do tabuleiro */
      --h: calc(var(--cell) * 20);
      /* Altura do tabuleiro */
    }

    body {
      margin: 0;
      /* Remove margem padrão */
      padding: 0;
      /* Remove padding padrão */
      font-family: "Comic Sans MS", cursive, sans-serif;
      /* Fonte padrão */
      color: white;
      /* Cor do texto */
      overflow: hidden;
      /* Esconde scroll */
      background: #000;
      /* Fundo preto */
    }

    .screen {
      position: absolute;
      /* Tela posicionada relativa ao pai */
      top: 0;
      /* Alinha topo */
      left: 0;
      /* Alinha esquerda */
      width: 100vw;
      /* Largura da tela */
      height: 100vh;
      /* Altura da tela */
      display: flex;
      /* Ativa flexbox */
      flex-direction: column;
      /* Organiza elementos em coluna */
      justify-content: center;
      /* Centraliza verticalmente */
      align-items: center;
      /* Centraliza horizontalmente */
      opacity: 0;
      /* Invisível por padrão */
      pointer-events: none;
      /* Não interage por padrão */
      transition: opacity 0.6s ease-in-out;
      /* Transição suave */
      z-index: 0;
      /* Camada inferior */
    }

    .screen.active {
      opacity: 1;
      /* Tela visível */
      pointer-events: auto;
      /* Interação habilitada */
      z-index: 1;
      /* Camada acima */
    }

    .bg-image {
      position: absolute;
      /* Imagem fixa dentro da tela */
      inset: 0;
      /* Preenche toda a tela */
      width: 100vw;
      /* Largura total */
      height: 100vh;
      /* Altura total */
      object-fit: cover;
      /* Cobre área inteira cortando excesso */
      object-position: center;
      /* Centraliza a imagem */
      z-index: -1;
      /* Fica atrás do conteúdo */
    }

    button {
      padding: 15px 30px;
      /* Espaçamento interno */
      font-size: 18px;
      /* Tamanho do texto */
      font-weight: bold;
      /* Texto em negrito */
      border: 4px solid black;
      /* Borda preta */
      border-radius: 20px;
      /* Arredonda cantos */
      background: orange;
      /* Cor de fundo */
      cursor: pointer;
      /* Muda cursor */
      transition: transform 0.2s ease-in-out;
      /* Efeito de hover */
      color: #000;
      /* Cor do texto */
    }

    button:hover {
      transform: scale(1.1);
      /* Aumenta botão ao passar o mouse */
    }

    input {
      padding: 12px;
      /* Espaçamento interno */
      margin: 10px 0;
      /* Margem superior e inferior */
      border-radius: 50px;
      /* Bordas arredondadas */
      border: 2px solid black;
      /* Borda preta */
      text-align: center;
      /* Texto centralizado */
      font-size: 16px;
      /* Tamanho do texto */
      background-color: #333333;
      /* Fundo escuro */
      color: white;
      /* Cor do texto */
      opacity: 0.9;
      /* Transparência levemente menor */
      font-family: Arial, Helvetica, sans-serif;
      /* Fonte alternativa */
    }

    input::placeholder {
      color: white;
      /* Cor do placeholder */
    }

    .row {
      display: flex;
      /* Alinha elementos em linha */
      gap: 20px;
      /* Espaço entre elementos */
      justify-content: center;
      /* Centraliza horizontalmente */
      margin-top: 20px;
      /* Margem superior */
    }

    #cadastro,
    #login {
      padding-top: 90px;
      /* Espaço acima dos inputs */
    }

    #cadastro input,
    #login input {
      width: 260px;
      /* Largura do input */
      height: 30px;
      /* Altura do input */
      font-size: 18px;
      /* Tamanho do texto */
      font-family: Comic sans-serif;
      /* Fonte específica */
    }

    #cadastro button,
    #login button {
      padding: 18px 40px;
      /* Espaçamento interno */
      font-size: 20px;
      /* Tamanho do texto */
    }

    #menu {
      position: relative;
      /* Posicionamento relativo para filhos */
    }

    .start-btn {
      position: absolute;
      /* Posiciona botão no menu */
      right: 95px;
      /* Distância da direita */
      bottom: 120px;
      /* Distância de baixo */
      padding: 7px 60px;
      /* Espaçamento interno */
      font-size: 18px;
      /* Tamanho do texto */
      font-weight: bold;
      /* Texto em negrito */
      border: 2px solid black;
      /* Borda preta */
      border-radius: 10px;
      /* Bordas arredondadas */
      background: #deb02a;
      /* Fundo amarelo */
      cursor: pointer;
      /* Muda cursor */
      transition: transform 0.2s ease-in-out;
      /* Animação ao passar o mouse */
    }

    #jogo .game-container {
      display: grid;
      /* Ativa grid */
      grid-template-columns: 1fr minmax(320px, var(--w)) 1fr;
      /* Colunas do grid */
      gap: 200px;
      /* Espaço entre colunas */
      width: 100%;
      /* Largura total */
      height: 100%;
      /* Altura total */
      padding: 20px;
      /* Espaço interno */
      box-sizing: border-box;
      /* Inclui padding na largura */
    }

    .left-panel,
    .right-panel {
      display: flex;
      /* Ativa flexbox */
      flex-direction: column;
      /* Organiza verticalmente */
      align-items: center;
      /* Centraliza horizontalmente */
      justify-content: flex-start;
      /* Alinha no topo */
      gap: 20px;
      /* Espaço entre itens */
    }

    .left-panel {
      margin-top: 100px;
      /* Espaço acima painel esquerdo */
    }

    .right-panel {
      margin-top: 150px;
      /* Espaço acima painel direito */
    }

    .start-btn,
    .stop-btn {
      width: 200px;
      /* Largura do botão */
      height: 6px;
      /* Altura do botão (visual) */
      padding: 20px;
      /* Espaçamento interno */
      font-size: 20px;
      /* Tamanho do texto */
      font-weight: bold;
      /* Negrito */
      border: 2px solid black;
      /* Borda preta */
      border-radius: 30px;
      /* Bordas arredondadas */
      background: #deb02a;
      /* Fundo amarelo */
      cursor: pointer;
      /* Muda cursor */
      transition: transform 0.2s ease-in-out;
      /* Animação hover */
      display: flex;
      /* Flexbox interno */
      justify-content: center;
      /* Centraliza horizontal */
      align-items: center;
      /* Centraliza vertical */
    }

    .info-box {
      background-color: #ffc81c;
      /* Fundo amarelo */
      border: 5px solid black;
      /* Borda preta */
      border-radius: 15px;
      /* Cantos arredondados */
      padding: 10px 20px;
      /* Espaçamento interno */
      font-weight: bold;
      /* Texto em negrito */
      font-size: 18px;
      /* Tamanho do texto */
      color: black;
      /* Cor do texto */
      text-align: center;
      /* Centraliza texto */
      min-width: 170px;
      /* Largura mínima */
      margin-bottom: 10px;
      /* Espaço abaixo */
    }

    .hold {
      background-color: #ffc81c;
      /* Fundo amarelo */
      border: 5px solid black;
      /* Borda preta */
      border-radius: 15px;
      /* Cantos arredondados */
      padding: 10px;
      /* Espaçamento interno */
      width: 265px;
      /* Largura do container */
      height: 265px;
      /* Altura do container */
      display: flex;
      /* Ativa flexbox */
      flex-direction: column;
      /* Organiza conteúdo em coluna */
      align-items: center;
      /* Centraliza horizontalmente */
      font-weight: bold;
      /* Texto em negrito */
      color: black;
      /* Cor do texto */
      margin-bottom: 10px;
      /* Espaço abaixo do container */
    }

    .next {
      background-color: #ffc81c;
      /* Fundo amarelo */
      border: 5px solid black;
      /* Borda preta */
      border-radius: 15px;
      /* Cantos arredondados */
      padding: 10px;
      /* Espaçamento interno */
      width: 265px;
      /* Largura do container */
      height: 265px;
      /* Altura do container */
      display: flex;
      /* Ativa flexbox */
      flex-direction: column;
      /* Organiza conteúdo em coluna */
      align-items: center;
      /* Centraliza horizontalmente */
      font-weight: bold;
      /* Texto em negrito */
      color: black;
      /* Cor do texto */
      margin-bottom: 10px;
      /* Espaço abaixo do container */
    }

    .hold::before,
    .next::before {
      content: attr(data-title);
      /* Exibe o texto do atributo data-title */
      margin-bottom: 10px;
      /* Espaço abaixo do texto */
      font-size: 18px;
      /* Tamanho do texto */
    }

    .hold-display,
    .next-display {
      background-color: orange;
      /* Fundo laranja */
      width: 90%;
      /* Largura do display */
      height: 200px;
      /* Altura do display */
      border-radius: 10px;
      /* Cantos arredondados */
      border: 4px solid black;
      /* Borda preta */
      display: grid;
      /* Ativa grid para centralizar conteúdo */
      place-items: center;
      /* Centraliza conteúdo vertical e horizontal */
    }

    .game-board {
      display: grid;
      /* Ativa grid */
      place-items: center;
      /* Centraliza o canvas do tabuleiro */
    }

    #board {
      width: var(--w);
      /* Largura definida pelo CSS root */
      height: var(--h);
      /* Altura definida pelo CSS root */
      image-rendering: pixelated;
      /* Renderiza pixels nítidos */
      border: 6px solid #000;
      /* Borda preta */
      box-shadow: 0 0 0 5px #ffc81c, 0 0 30px rgba(0, 0, 0, .6);
      /* Sombra e efeito visual */
      background: #111;
      /* Fundo escuro */
      border-radius: 10px;
      /* Cantos arredondados */
    }

    .mini {
      width: 220px;
      /* Largura do mini-canvas */
      height: 160px;
      /* Altura do mini-canvas */
      image-rendering: pixelated;
      /* Renderiza pixels nítidos */
      border-radius: 8px;
      /* Cantos arredondados */
      background: #111;
      /* Fundo escuro */
      border: 4px solid #000;
      /* Borda preta */
      box-shadow: 0 0 0 4px #ffb000 inset;
      /* Sombra interna */
    }

    input.error {
      border: 2px solid red;
      /* Borda vermelha para erro */
      animation: shake 0.3s;
      /* Animação de tremor */
    }

    @keyframes shake {
      0% {
        transform: translateX(0);
      }
      /* Início sem movimento */
      25% {
        transform: translateX(-5px);
      }
      /* Move para esquerda */
      50% {
        transform: translateX(5px);
      }
      /* Move para direita */
      75% {
        transform: translateX(-5px);
      }
      /* Move para esquerda */
      100% {
        transform: translateX(0);
      }
      /* Volta à posição inicial */
    }

    .error-message {
      color: red;
      /* Cor vermelha */
      font-weight: bold;
      /* Texto em negrito */
      margin-top: 10px;
      /* Espaço acima da mensagem */
      display: none;
      /* Inicialmente escondida */
    }

    #score-screen .card {
      background: rgba(255, 200, 28, 0.95);
      /* Fundo amarelo semi-transparente */
      border: 6px solid #000;
      /* Borda preta */
      border-radius: 16px;
      /* Cantos arredondados */
      color: #000;
      /* Cor do texto */
      padding: 24px 28px;
      /* Espaçamento interno */
      text-align: center;
      /* Centraliza texto */
      min-width: 320px;
      /* Largura mínima do card */
      box-shadow: 0 10px 30px rgba(0, 0, 0, .4);
      /* Sombra do card */
    }

    #score-screen h2 {
      margin: 0 0 10px 0;
      /* Margem superior, direita e esquerda zero, inferior 10px */
    }

    #score-screen .big {
      font-size: 42px;
      /* Tamanho grande do texto */
      font-weight: 900;
      /* Negrito extremo */
      margin: 6px 0;
      /* Margem vertical 6px */
    }

    #score-screen .small {
      font-size: 14px;
      /* Tamanho pequeno */
      opacity: .8;
      /* Transparência levemente menor */
    }

    #boom {
      position: absolute;
      /* Posiciona imagem absoluta */
      top: 83%;
      /* Posição vertical */
      left: 87%;
      /* Posição horizontal */
      transform: translate(-50%, -50%) scale(0);
      /* Centraliza e inicia invisível */
      width: 500px;
      /* Largura da imagem */
      pointer-events: none;
      /* Clique não afeta a imagem */
      opacity: 0;
      /* Inicialmente invisível */
      z-index: 1000;
      /* Sobrepõe outros elementos */
    }

    @keyframes boomAnim {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      /* Início invisível */
      20% {
        transform: translate(-50%, -50%) scale(1.2) rotate(-3deg);
        opacity: 1;
      }
      /* Explosão começa */
      40% {
        transform: translate(-50%, -50%) scale(1) rotate(3deg);
      }
      /* Ajuste visual */
      60% {
        transform: translate(-50%, -50%) scale(1.1) rotate(-2deg);
      }
      /* Pequena oscilação */
      80% {
        transform: translate(-50%, -50%) scale(1) rotate(2deg);
      }
      /* Pequena oscilação */
      100% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      /* Termina invisível */
    }

    .boom-active {
      animation: boomAnim 1.0s ease forwards;
      /* Ativa animação de explosão */
    }

    .side-actions {
      display: grid;
      /* Ativa grid */
      grid-template-columns: repeat(2, 80px);
      /* Define 2 colunas de 80px */
      gap: 20px;
      /* Espaço entre colunas */
      justify-items: center;
      /* Centraliza horizontalmente cada item */
      align-items: center;
      /* Centraliza verticalmente cada item */
      margin-top: 6px;
      /* Espaço acima da seção */
      position: relative;
      /* Mantém posição relativa dentro do fluxo */
      pointer-events: auto;
      /* Permite interação */
    }

    .commands-box {
      position: absolute;
      /* Posiciona a caixa absoluta */
      left: 40px;
      /* Distância da esquerda */
      bottom: 110px;
      /* Distância de baixo */
      background: rgba(255, 200, 28, 0.9);
      /* Fundo amarelo semi-transparente */
      border: 4px solid black;
      /* Borda preta */
      border-radius: 12px;
      /* Cantos arredondados */
      padding: 30px 35px;
      /* Espaçamento interno */
      color: #000;
      /* Cor do texto */
      font-size: 20px;
      /* Tamanho do texto */
      font-weight: bold;
      /* Negrito */
      max-width: 250px;
      /* Largura máxima */
    }

    .commands-box h3 {
      margin: 0 0 10px 0;
      /* Margem inferior 10px */
      font-size: 20px;
      /* Tamanho do texto */
      text-align: left;
      /* Alinha texto à esquerda */
    }

    .commands-box ul {
      margin: 0;
      /* Remove margem padrão */
      padding-left: 20px;
      /* Espaço interno à esquerda */
    }

    .commands-box li {
      margin-bottom: 6px;
      /* Espaço abaixo de cada item */
    }

    .guest-btn {
      display: flex;
      /* Ativa flexbox */
      align-items: center;
      /* Centraliza verticalmente */
      justify-content: center;
      /* Centraliza horizontalmente */
      margin-top: -45px;
      /* Ajusta posição vertical */
      margin-left: 400px;
      /* Ajusta posição horizontal */
      padding: 20px 45px;
      /* Espaçamento interno */
      width: 170px;
      /* Largura do botão */
      height: 40px;
      /* Altura do botão */
      font-size: 12px !important;
      /* Tamanho do texto com prioridade */
      font-weight: bold;
      /* Negrito */
      border-radius: 40px;
      /* Bordas arredondadas */
      border: 3px solid white;
      /* Borda branca */
      background: #111;
      /* Fundo escuro */
      color: #f4b52e;
      /* Cor do texto */
      cursor: pointer;
      /* Cursor mão */
      transition: transform 0.2s ease-in-out, background 0.2s;
      /* Animação hover */
    }

    .guest-btn:hover {
      transform: scale(1.15);
      /* Aumenta botão ao passar mouse */
      background: #222;
      /* Muda fundo ao passar mouse */
    }

    #game-timer {
      position: absolute;
      top: 6px;
      /* um pouco acima do jogo */
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      font-weight: bold;
      color: white;
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 15px;
      border-radius: 8px;
    }

    #insane-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: url("https://3.bp.blogspot.com/-yx4B4ZwhM-4/XLCYLYpV7zI/AAAAAAAABls/g7Z7ux_I3K47-DAvFfXmWzxQJCyLfm0UACLcBGAs/s640/maxresdefault%2B%25281%2529.jpg") no-repeat center center;
      background-size: cover;
    }

    .insane-box {
      margin-top: 450px;
      background: black;
      padding: 30px 50px;
      border: 3px solid red;
      border-radius: 12px;
      width: 500px;

    }

    .insane-box p {
      color: red;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      text-shadow: 0 0 10px #ff0000;
    }

    #btn-return {
      margin-top: 20px;
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      border: 3px solid red;
      border-radius: 12px;
      background: black;
      color: red;
      cursor: pointer;
      transition: transform 0.2s ease-in-out, background 0.2s;
    }

    #btn-return:hover {
      transform: scale(1.1);
      background: #222;
    }
  </style>
  </head>

<body>
  <div id="custom-notification"></div>
  <div id="cadastro" class="screen active">
    <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9c5dh5/9.png" alt="Fundo Cadastro">
    <input type="text" id="cad-username" placeholder="Username">
    <input type="password" id="cad-senha" placeholder="Senha">
    <input type="password" id="cad-confirma" placeholder="Confirmar Senha">
    <div class="row">
      <button onclick="showScreen('login')">LOGIN</button>
      <button onclick="cadastrar()">CADASTRAR-SE</button>
      </div>
  </div>

  <div id="login" class="screen">
    <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9hycr4/10.png" alt="Fundo Login">
    <input type="text" id="login-username" placeholder="Username">
    <input type="password" id="login-senha" placeholder="Senha">
    <div id="login-error" class="error-message">Usuário ou senha incorretos!</div>
    <div class="row">
      <button onclick="logar()">LOGAR</button>
      </div>
    <button id="guestBtn" class="guest-btn">MODO CONVIDADO</button>
    </div>

  <div id="menu" class="screen">
    <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9gqwxd/11.png" alt="Fundo Menu">
    <div class="commands-box">
      <h2>Comandos</h2>
      <ul>
        <li>← / → : Mover peça</li>
        <li>↓ : Soft drop</li>
        <li>↑ ou X : Girar horário</li>
        <li>Z : Girar anti-horário</li>
        <li>Espaço : Hard drop</li>
        <li>C : Segurar (Hold)</li>
        <li>P : Pausar</li>
        <li>Esc : Voltar ao Menu ou tela de login</li>
        </ul>
    </div>
    <div class="menu-content">
      <button class="start-btn" onclick="startFromMenu()">START</button>
      <div style="position:absolute; left:40px; bottom:40px;">
        <button onclick="showScreen('settings')">CONFIGURAÇÕES</button>
      </div>
      </div>
  </div>

  <div id="jogo" class="screen">
    <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9gqwxd/12.png" alt="Fundo Jogo">
    <div id="game-timer">Tempo: 0s</div>
    <div class="game-container">
      <div class="left-panel">
        <div class="info-box score">SCORE: 0</div>
        <div class="info-box level">LEVEL: 1</div>
        <div class="info-box lines">LINES: 0</div>
        <div class="hold" data-title="HOLD">
          <div class="hold-display">
            <canvas id="hold" class="mini" width="220" height="160"></canvas>
            </div>
        </div>
      </div>

      <div id="pause-screen">
        <h2>PAUSADO</h2>
        <div class="pause-buttons">
          <button id="btn-restart"><img src="https://cdn-icons-png.flaticon.com/512/3594/3594008.png" alt="Reiniciar" /></button>
          <button id="btn-resume"><img src="https://cdn-icons-png.flaticon.com/512/16/16427.png" alt="Continuar" /></button>
          <button id="btn-menu"><img src="https://cdn-icons-png.flaticon.com/512/7216/7216128.png" alt="Menu" /></button>
          </div>

        <!-- NOVO: links dos desenvolvedores na tela de pausa -->
        <div class="dev-links" aria-label="Desenvolvedores">
          <div>Desenvolvedores:</div>
          <a href="https://github.com/ShadowNote012" target="_blank" rel="noopener">Luiz</a>
          <a href="https://github.com/AlmightyBeef" target="_blank" rel="noopener">Gabriel Furtado</a>
          <a href="https://github.com/CleitinQueijo" target="_blank" rel="noopener">Gabriel Santos</a>
          <a href="https://github.com/rodriguessoaresarthurmiguel-lgtm" target="_blank" rel="noopener">Arthur</a>
        </div>
      </div>

      <div class="game-board">
        <canvas id="board" width="300" height="600"></canvas>
        </div>

      <div class="right-panel">
        <div class="next" data-title="NEXT">
          <div class="next-display">
            <canvas id="next" class="mini" width="220" height="160"></canvas>
            </div>
        </div>
      </div>
    </div>
  </div>

  <!-- NOVA TELA: CONFIGURAÇÕES -->
  <div id="settings" class="screen">
  <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9gqwxd/11.png" alt="Fundo Configurações">

  <!-- PAINEL CENTRAL COM FUNDO AMARELO -->
  <div style="
    background: #ffc81c;
    width: 500px;
    height: 600px;
    border: 5px solid #000;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding-top: 30px;
    text-align: center;
    box-shadow: 0 8px 25px rgba(0,0,0,0.4);
  ">
    <h2 style="
      color:#000;
      background:#deb02a;
      padding:10px 30px;
      border-radius:10px;
      margin-bottom:20px;
    ">CONFIGURAÇÕES</h2>

    <div style="margin-top:10px;">
      <label for="volume" style="color:black; font-weight:bold;">Volume:</label>
      <input type="range" id="volume" min="0" max="1" step="0.05" value="0.5"
        oninput="setVolume(this.value)" style="width:200px;">
    </div>

    <div style="margin-top:25px;">
      <button id="sound-toggle" onclick="toggleSound()">Desligar Som</button>
    </div>

    <h3 style="color:black; margin-top:40px;">Desenvolvedores</h3>

    <div class="dev-links" style="
      background: rgba(255,200,28,0.95);
      width: 80%;
      text-align:center;
      border: 3px solid #000;
      border-radius:12px;
      padding:10px 15px;
      margin-top:10px;
    ">
      <a href="https://github.com/ShadowNote012" target="_blank" rel="noopener">Luiz — @ShadowNote012</a>
      <a href="https://github.com/AlmightyBeef" target="_blank" rel="noopener">Gabriel Furtado — @AlmightyBeef</a>
      <a href="https://github.com/CleitinQueijo" target="_blank" rel="noopener">Gabriel Santos — @CleitinQueijo</a>
      <a href="https://github.com/rodriguessoaresarthurmiguel-lgtm" target="_blank" rel="noopener">Arthur — @rodriguessoaresarthurmiguel-lgtm</a>
    </div>

    <div class="row" style="margin-top:25px;">
      <button onclick="showScreen('menu')">VOLTAR</button>
    </div>
  </div>
</div>

  <div id="score-screen" class="screen">
    <img class="bg-image" src="https://uploads.onecompiler.io/43rztn6g5/43u9gqwxd/12.png" alt="Fundo Score">
    <div class="card">
      <h2>GAME OVER</h2>
      <div class="small" id="score-user"></div>
      <div class="big" id="final-score">0</div>
      <div class="small">High Score: <span id="high-score">0</span></div>
      <div class="row" style="margin-top:18px;">
        <button onclick="restartGame()">REINICIAR</button>
        <button onclick="showScreen('menu')">MENU</button>
        </div>
      <p class="small" style="margin-top:10px;">
      </p>
    </div>
  </div>

  <div id="insane-screen" class="screen">
    <div class="insane-box">
      <p>YOU IS INSANE</p>
      <button id="btn-return">CONTINUAR JOGO</button>
    </div>
  </div>


  <div id="hud-username" style="position: absolute; top: 15px; right: 20px; color: black; font-weight: bold; font-size: 30px; z-index: 10; display: none;"></div>
  <img id="boom" src="https://uploads.onecompiler.io/43rztn6g5/43unkwz55/Score14.png" alt="Boom Explosion" />
  <script>
    let isPaused = false; // Variável global que controla se o jogo está pausado
    let timerInterval;
    let startTime;
    let elapsedBeforePause = 0; // tempo acumulado antes da pausa

    function startTimer() {
      startTime = Date.now();
      const timerEl = document.getElementById("game-timer");

      timerInterval = setInterval(() => {
        if (!game || game.paused) return; // não atualiza se jogo pausado

        const elapsed = elapsedBeforePause + (Date.now() - startTime);

        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        const milliseconds = Math.floor((elapsed % 1000) / 10);

        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');
        const msStr = String(milliseconds).padStart(2, '0');

        timerEl.textContent = `Tempo: ${minStr}:${secStr}:${msStr}`;
      }, 10);
    }

    // Para o cronômetro (quando sair do jogo ou reiniciar)
    function stopTimer() {
      clearInterval(timerInterval);
    }

    // Chamada quando o jogador pausa ou despausa com P
    function pauseTimer() {
      if (!game) return;
      if (game.paused) {
        // Acumula tempo até o momento da pausa
        elapsedBeforePause += Date.now() - startTime;
      } else {
        // Reinicia contagem sem zerar o acumulado
        startTime = Date.now();
      }
    }


    // Evento de teclado para pausar/despausar com "P"
    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "p") { // Verifica se a tecla pressionada é 'P'
        isPaused = !isPaused; // Alterna estado de pausa
        document.getElementById("pause-screen").style.display = isPaused ? "flex" : "none"; // Mostra/oculta overlay de pausa

        if (isPaused) {
          // Quando pausa
          console.log("Jogo pausado"); // Debug
        } else {
          // Quando retoma
          console.log("Jogo retomado"); // Debug
        }
      }
    });

    // ======= TRILHA SONORA =======
    const bgMusic = new Audio("Battle Ready.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.5; // volume inicial médio
    let musicEnabled = true;

    function playMusic() {
      if (!musicEnabled) return;
      bgMusic.play().catch(err => {
        // autoplay pode falhar em navegadores sem interação; silêncio o erro
        // console.log("Erro ao tocar música:", err);
      });
    }

    function pauseMusic() {
      try {
        bgMusic.pause();
      } catch (e) {
        // ignore
      }
    }

    function setVolume(value) {
      const v = parseFloat(value);
      bgMusic.volume = v;
      // Atualiza valor do slider caso seja chamado por código
      const volEl = document.getElementById('volume');
      if (volEl) volEl.value = v;
    }

    function toggleSound() {
      musicEnabled = !musicEnabled;
      if (musicEnabled) {
        playMusic();
        document.getElementById("sound-toggle").textContent = "Desligar Som";
      } else {
        pauseMusic();
        document.getElementById("sound-toggle").textContent = "Ligar Som";
      }
    }

    // Botão "Retomar" do menu de pausa
    document.getElementById("btn-resume").addEventListener("click", () => {
      if (!game) return; // Evita erro se o jogo ainda não começou
      game.paused = false; // Despausa o jogo
      isPaused = false; // Atualiza variável global
      document.getElementById("pause-screen").style.display = "none"; // Oculta overlay de pausa
      game.lastTime = 0; // Reseta temporizador
      game.loopId = requestAnimationFrame(game.update.bind(game)); // Retoma loop de atualização
      // retoma música se estiver habilitado
      playMusic();
    });

    // Botão "Reiniciar" do menu de pausa
    document.getElementById("btn-restart").addEventListener("click", () => {
      showScreen('jogo'); // Garante que a tela do jogo esteja ativa
      startGame(); // Reinicia o Tetris
      isPaused = false; // Remove pausa
      document.getElementById("pause-screen").style.display = "none"; // Oculta overlay
      console.log("Jogo reiniciado"); // Debug
      // toca música novamente
      playMusic();
    });

    // Botão "Menu" do menu de pausa
    document.getElementById("btn-menu").addEventListener("click", () => {
      isPaused = false; // Remove pausa
      document.getElementById("pause-screen").style.display = "none"; // Oculta overlay
      showScreen('menu'); // Mostra tela de menu
      // pausa música ao voltar ao menu
      pauseMusic();
    });

    // Botão de retorno da tela INSANE
    document.getElementById("btn-return").addEventListener("click", () => {
      if (game) {
        showScreen("jogo"); // ativa a tela do jogo
        game.paused = false;
        game.gameOver = false; // desbloqueia game over
        game.lastTime = 0;

        // redesenha imediatamente
        game.drawAll();

        // retoma loop
        game.loopId = requestAnimationFrame(game.update.bind(game));

        // reativa controles
        document.addEventListener("keydown", game.handleKeyDown);

        // retoma cronômetro
        startTimer();

        // retoma música
        playMusic();
      }
    });




    // Função para exibir notificações temporárias
    function showNotification(text, duration = 2000) {
      const notif = document.getElementById('custom-notification'); // Seleciona elemento
      notif.textContent = text; // Define mensagem
      notif.style.display = 'block'; // Mostra notificacao
      setTimeout(() => {
        notif.style.display = 'none';
      }, duration); // Oculta após duração
    }

    /* ========= Navegação entre telas / Login ========= */

    // Mostra tela especificada e oculta as outras
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); // Remove classe 'active' de todas as telas
      document.getElementById(screenId).classList.add('active'); // Adiciona classe 'active' à tela desejada
    }

    // Função de cadastro de usuário
    function cadastrar() {
      let user = document.getElementById("cad-username").value.trim(); // Pega nome de usuário
      let senha = document.getElementById("cad-senha").value; // Pega senha
      let confirma = document.getElementById("cad-confirma").value; // Pega confirmação de senha

      if (!user || !senha || !confirma) {
        showNotification("Preencha todos os campos!"); // Mensagem de erro
        return;
      }
      if (senha !== confirma) {
        showNotification("As senhas não coincidem!"); // Mensagem de erro
        return;
      }

      let usuarios = JSON.parse(localStorage.getItem("usuarios")) || []; // Recupera usuários do localStorage
      if (usuarios.find(u => u.username === user)) {
        showNotification("Usuário já cadastrado!"); // Mensagem de erro
        return;
      }

      usuarios.push({
        username: user,
        senha: senha
      }); // Adiciona novo usuário
      localStorage.setItem("usuarios", JSON.stringify(usuarios)); // Salva no localStorage
      showNotification("Cadastro realizado com sucesso!"); // Mensagem de sucesso
      showScreen('login'); // Mostra tela de login após cadastro
    }

    // Botão "Entrar como Convidado"
    document.getElementById('guestBtn').addEventListener('click', () => {
      currentUser = 'Convidado'; // Define usuário atual como convidado
      const hudUsername = document.getElementById("hud-username");
      hudUsername.textContent = currentUser; // Mostra nome na HUD
      hudUsername.style.display = "block";

      showNotification("Entrou como convidado!"); // Mensagem de sucesso
      showScreen('menu'); // Vai para menu
    });

    // Função de login de usuário
    function logar() {
      let userInput = document.getElementById("login-username"); // Input usuário
      let senhaInput = document.getElementById("login-senha"); // Input senha
      let errorMsg = document.getElementById("login-error"); // Mensagem de erro

      let usuarios = JSON.parse(localStorage.getItem("usuarios")) || []; // Recupera usuários
      let usuarioValido = usuarios.find(u => u.username === userInput.value.trim() && u.senha === senhaInput.value); // Verifica credenciais

      if (usuarioValido) {
        errorMsg.style.display = "none"; // Oculta erro
        userInput.classList.remove("error"); // Remove estilo de erro
        senhaInput.classList.remove("error");

        const hudUsername = document.getElementById("hud-username");
        hudUsername.textContent = usuarioValido.username; // Mostra usuário
        hudUsername.style.display = "block";

        currentUser = usuarioValido.username; // Atualiza usuário atual
        showScreen('menu'); // Vai para menu
      } else {
        errorMsg.style.display = "block"; // Mostra erro
        userInput.classList.add("error"); // Adiciona estilo de erro
        senhaInput.classList.add("error");
        setTimeout(() => {
          userInput.classList.remove("error");
          senhaInput.classList.remove("error");
        }, 400); // Remove erro após 400ms
      }
    }

    // Inicia jogo a partir do menu
    function startFromMenu() {
      // Efeito visual "boom"
      boom.classList.remove("boom-active");
      void boom.offsetWidth; // Força reflow
      boom.classList.add("boom-active");

      showScreen('jogo'); // Mostra tela do jogo
      startGame(); // Inicia partida
    }

    /* ========= JOGO ========= */
    const COLS = 10,
      ROWS = 20; // Número de colunas e linhas do tabuleiro
    const EMPTY = 0; // Valor que representa célula vazia
    // Cores das peças (alteradas para não serem iguais às originais)
    const COLORS = {
      I: '#ff69b4',
      J: '#8a2be2',
      L: '#ffa500',
      O: '#00ced1',
      S: '#adff2f',
      T: '#ff4500',
      Z: '#7fff00'
    };
    // Formatos das peças (matriz 2D)
    const SHAPES = {
      I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      J: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      L: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ],
      O: [
        [1, 1],
        [1, 1]
      ],
      S: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      T: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      Z: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ]
    };
    const PIECES = Object.keys(SHAPES); // Tipos de peças disponíveis

    let currentUser = null; // Usuário atual
    let game = null; // Instância do jogo

    // Classe principal do jogo
    class Game {
      constructor() {
        this.freezeUses = 3; // Número de congelamentos disponíveis
        this.isFrozen = false; // Flag de congelamento
        this.bombUses = 3; // Número de bombas disponíveis

        // Canvas do tabuleiro principal
        this.boardCanvas = document.getElementById('board');
        this.bctx = this.boardCanvas.getContext('2d');

        // Canvas da próxima peça
        this.nextCanvas = document.getElementById('next');
        this.nctx = this.nextCanvas.getContext('2d');

        // Canvas da peça em hold
        this.holdCanvas = document.getElementById('hold');
        this.hctx = this.holdCanvas.getContext('2d');

        // Elementos de HUD
        this.scoreEl = document.querySelector('.info-box.score');
        this.levelEl = document.querySelector('.info-box.level');
        this.linesEl = document.querySelector('.info-box.lines');

        this.handleKeyDown = this.onKeyDown.bind(this); // Bind do evento de teclado

        this.reset(); // Inicializa o jogo
      }

      reset() {
        this.grid = Array.from({
          length: ROWS
        }, () => Array(COLS).fill(EMPTY)); // Cria grid vazia
        this.score = 0; // Reseta pontuação
        this.level = 1; // Reseta nível
        this.lines = 0; // Reseta linhas
        this.dropCounter = 0; // Contador de queda
        this.dropInterval = this.levelToInterval(this.level); // Intervalo de queda
        this.lastTime = 0; // Último timestamp
        this.paused = false; // Pausa inicial
        this.gameOver = false; // Flag de fim de jogo

        this.holdPiece = null; // Peça em hold
        this.holdLocked = false; // Bloqueio de hold

        this.bag = []; // Sacola de peças
        this.queue = []; // Fila de próximas peças
        this.fillBag();
        this.fillBag(); // Preenche a fila de peças

        this.spawn(); // Gera primeira peça

        this.updatePanels(); // Atualiza HUD
        this.drawAll(); // Desenha tudo

        document.addEventListener('keydown', this.handleKeyDown); // Ativa controle de teclado
        this.loopId = requestAnimationFrame(this.update.bind(this)); // Inicia loop principal
      }

      levelToInterval(level) {
        // Retorna intervalo de queda em ms baseado no nível
        const table = [1000, 793, 618, 473, 355, 262, 190, 135, 94, 64];
        return level <= 10 ? table[level - 1] : Math.max(64 - (level - 10) * 3, 30);
      }

      fillBag() {
        // Método 7-bag randomizado
        let bag = [...PIECES]; // Copia tipos de peças
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]]; // Embaralha
        }
        this.bag.push(...bag); // Adiciona à sacola
        while (this.queue.length < 5 && this.bag.length) {
          this.queue.push(this.bag.shift()); // Preenche fila de próximas
        }
      }

      spawn() {
        if (this.queue.length < 3) this.fillBag(); // Garante fila mínima
        const type = this.queue.shift(); // Pega primeira peça da fila
        if (this.bag.length) this.queue.push(this.bag.shift()); // Reabastece fila
        const matrix = this.cloneMatrix(SHAPES[type]); // Matriz da peça
        const color = COLORS[type]; // Cor da peça
        const x = Math.floor((COLS - matrix[0].length) / 2); // Posição X central
        const y = -this.spawnOffset(matrix); // Posição Y considerando linhas vazias no topo
        this.active = {
          type,
          matrix,
          color,
          x,
          y
        }; // Define peça ativa
        this.holdLocked = false; // Desbloqueia hold

        if (this.collides(this.active, this.grid)) { // Checa colisão inicial
          this.finish(); // Se colidir, fim de jogo
        }

        this.updatePanels(); // Atualiza HUD
      }

      spawnOffset(matrix) {
        // Remove linhas vazias no topo da peça
        let empty = 0;
        for (let r = 0; r < matrix.length; r++) {
          if (matrix[r].every(v => v === 0)) empty++;
          else break;
        }
        return empty; // Retorna número de linhas vazias
      }

      cloneMatrix(m) {
        return m.map(row => row.slice());
      } // Copia matriz sem referência

      rotate(matrix, dir) {
        // Rotaciona matriz: CW ou CCW
        const M = matrix.length,
          N = matrix[0].length;
        let res = Array.from({
          length: N
        }, () => Array(M).fill(0)); // Nova matriz
        for (let r = 0; r < M; r++)
          for (let c = 0; c < N; c++) res[c][M - 1 - r] = matrix[r][c]; // Transposta + reverso
        return dir > 0 ? res : this.rotate(this.rotate(this.rotate(matrix, 1), 1), 1); // CCW = 3x CW
      }

      collides(piece, grid) {
        // Verifica colisão da peça com grid ou bordas
        const {
          matrix,
          x,
          y
        } = piece;
        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[0].length; c++) {
            if (!matrix[r][c]) continue;
            const nx = x + c;
            const ny = y + r;
            if (nx < 0 || nx >= COLS || ny >= ROWS) return true; // Colisão com borda
            if (ny >= 0 && grid[ny][nx] !== EMPTY) return true; // Colisão com outra peça
          }
        }
        return false; // Sem colisão
      }

      merge(piece) {
        // Mescla peça na grade
        const {
          matrix,
          x,
          y,
          color
        } = piece;
        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[0].length; c++) {
            if (matrix[r][c]) {
              const ny = y + r;
              if (ny >= 0) this.grid[ny][x + c] = color; // Coloca cor no grid
            }
          }
        }
      }

      sweep() {
        // Remove linhas completas
        let cleared = 0;
        outer: for (let r = ROWS - 1; r >= 0; r--) {
          for (let c = 0; c < COLS; c++)
            if (this.grid[r][c] === EMPTY) {
              continue outer;
            } // Se célula vazia, continua
          const row = this.grid.splice(r, 1)[0].fill(EMPTY); // Remove linha cheia
          this.grid.unshift(row); // Adiciona no topo
          cleared++;
          r++; // Recheca linha após unshift
        }
        if (cleared) {
          this.lines += cleared; // Atualiza linhas
          const base = [0, 100, 300, 500, 800][cleared]; // Pontuação base
          this.score += base * this.level; // Aplica pontuação

          const newLevel = 1 + Math.floor(this.lines / 10); // Calcula novo nível
          if (newLevel !== this.level) {
            this.level = newLevel; // Atualiza nível
            this.dropInterval = this.levelToInterval(this.level); // Atualiza intervalo
          }
          this.updatePanels(); // Atualiza HUD
        }
      }

      hardDrop() {
        // Queda instantânea da peça
        let cells = 0;
        while (!this.collides({ ...this.active,
            y: this.active.y + 1
          }, this.grid)) {
          this.active.y++;
          cells++; // Move pra baixo até colidir
        }
        this.score += cells * 2; // Bonus de hard drop
        this.lockPiece(); // Trava peça na grade
      }

      softDrop() {
        // Queda suave da peça
        if (!this.collides({ ...this.active,
            y: this.active.y + 1
          }, this.grid)) {
          this.active.y++;
          this.score += 1; // Move e pontua
        } else {
          this.lockPiece(); // Trava peça se colidir
        }
        this.updatePanels(); // Atualiza HUD
      }

      move(dir) {
        // Move horizontalmente (-1=esq, 1=dir)
        const nx = this.active.x + dir;
        if (!this.collides({ ...this.active,
            x: nx
          }, this.grid)) {
          this.active.x = nx; // Aplica movimento se sem colisão
        }
      }

      rotateActive(dir) {
        // Rotaciona peça ativa
        const rotated = this.rotate(this.active.matrix, dir);
        let test = { ...this.active,
          matrix: rotated
        };
        const kicks = [0, -1, 1, -2, 2]; // Tentativas de "wall kick"
        for (let dx of kicks) {
          if (!this.collides({ ...test,
              x: this.active.x + dx
            }, this.grid)) {
            this.active.matrix = rotated;
            this.active.x += dx; // Aplica rotação
            return;
          }
        }
      }

      hold() {
        // Guarda peça em hold
        if (this.holdLocked) return; // Só 1 hold por peça
        this.holdLocked = true;
        const currentType = this.active.type;
        if (!this.holdPiece) {
          this.holdPiece = currentType; // Guarda peça e gera nova
          this.spawn();
        } else {
          const temp = this.holdPiece;
          this.holdPiece = currentType;
          this.active = {
            type: temp,
            matrix: this.cloneMatrix(SHAPES[temp]),
            color: COLORS[temp],
            x: Math.floor((COLS - SHAPES[temp][0].length) / 2),
            y: -this.spawnOffset(SHAPES[temp])
          };
          if (this.collides(this.active, this.grid)) this.finish(); // Fim se colidir
        }
        this.drawHold(); // Atualiza canvas hold
      }

      lockPiece() {
        // Trava peça ativa na grade
        this.merge(this.active);
        this.sweep(); // Limpa linhas completas
        this.spawn(); // Gera nova peça
      }

      pauseToMenu() {
        // Para o loop de animação do jogo
        cancelAnimationFrame(this.loopId);

        // Remove os controles do jogo, para que Espaço, Setas, etc. não funcionem fora da tela de jogo
        document.removeEventListener("keydown", this.handleKeyDown);

        // Mostra a tela de menu
        showScreen("menu");

        // Pausa música ao ir para o menu
        pauseMusic();
      }

      finish() {
        // Finaliza jogo
        this.gameOver = true;
        cancelAnimationFrame(this.loopId);
        document.removeEventListener('keydown', this.handleKeyDown);
        const key = `tetris_highscore_${currentUser || 'guest'}`;
        const prev = parseInt(localStorage.getItem(key) || '0', 10);
        if (this.score > prev) localStorage.setItem(key, String(this.score));

        document.getElementById('score-user').textContent = currentUser ? `Player: ${currentUser}` : 'Player: Guest';
        document.getElementById('final-score').textContent = this.score;
        document.getElementById('high-score').textContent = localStorage.getItem(key) || '0';

        // Pausa música no fim do jogo
        pauseMusic();

        showScreen('score-screen'); // Mostra tela de pontuação final
      }

      onKeyDown(e) {
        // Só deixa rodar controles do jogo se a tela de jogo estiver ativa
        const jogoAtivo = document.getElementById("jogo").classList.contains("active");
        if (!jogoAtivo) return;

        if (this.gameOver) return;

        switch (e.key) {
          case 'ArrowLeft':
            if (!this.paused) this.move(-1);
            break;
          case 'ArrowRight':
            if (!this.paused) this.move(1);
            break;
          case 'ArrowDown':
            if (!this.paused) this.softDrop();
            break;
          case 'ArrowUp':
            if (!this.paused) this.rotateActive(1);
            break;
          case 'x':
          case 'X':
            if (!this.paused) this.rotateActive(1);
            break;
          case 'z':
          case 'Z':
            if (!this.paused) this.rotateActive(-1);
            break;
          case ' ':
            e.preventDefault();
            if (!this.paused) this.hardDrop();
            break;
          case 'c':
          case 'C':
            if (!this.paused) this.hold();
            break;
          case 'p':
          case 'P':
            this.paused = !this.paused;
            document.getElementById("pause-screen").style.display = this.paused ? "flex" : "none";
            if (!this.paused) {
              this.lastTime = 0;
              this.loopId = requestAnimationFrame(this.update.bind(this));
              // retoma música ao despausar
              playMusic();
            } else {
              cancelAnimationFrame(this.loopId);
              // pausa música ao pausar
              pauseMusic();
            }
            break;
          case 'Escape':
            this.pauseToMenu();
            break;
        }
        this.drawAll();
      }

      updatePanels() {
        // Atualiza HUD e miniaturas
        this.scoreEl.textContent = `SCORE: ${this.score}`;
        this.levelEl.textContent = `LEVEL: ${this.level}`;
        this.linesEl.textContent = `LINES: ${this.lines}`;
        this.drawNext();
        this.drawHold();
      }

      update(time = 0) {
        const delta = time - this.lastTime;
        this.lastTime = time;

        if (!this.paused && !this.gameOver) {
          this.dropCounter += delta;
          if (this.dropCounter > this.dropInterval) {
            this.dropCounter = 0;
            if (!this.collides({ ...this.active,
                y: this.active.y + 1
              }, this.grid)) {
              this.active.y++;
            } else {
              this.lockPiece();
            }
          }

          // ======= CHECAGEM INSANE =======
          const elapsed = elapsedBeforePause + (Date.now() - startTime);
          const minutes = Math.floor(elapsed / 60000);
          if (this.score >= 200000 || minutes >= 40) {
            cancelAnimationFrame(this.loopId);
            document.removeEventListener("keydown", this.handleKeyDown);
            stopTimer(); // pausa o cronômetro
            showScreen("insane-screen");
            return; // Sai do update
          }
          // ===============================

          this.drawAll();
          this.loopId = requestAnimationFrame(this.update.bind(this));
        }
      }

      /* ======= Desenho ======= */
      clearBoard() {
        // Limpa canvas principal
        this.bctx.fillStyle = '#111';
        this.bctx.fillRect(0, 0, this.boardCanvas.width, this.boardCanvas.height);
      }

      drawCell(ctx, x, y, size, color) {
        // Desenha célula
        ctx.fillStyle = color;
        ctx.fillRect(x, y, size, size);
        // Borda/shine
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
      }

      drawGrid() {
        // Desenha todas as células do tabuleiro
        const size = this.boardCanvas.width / COLS;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const val = this.grid[r][c];
            if (val !== EMPTY) this.drawCell(this.bctx, c * size, r * size, size, val);
          }
        }
      }

      drawPiece(piece, ghost = false) {
        // Desenha peça ativa
        const size = this.boardCanvas.width / COLS;
        let {
          matrix,
          x,
          y,
          color
        } = piece;

        if (ghost) { // Desenha sombra
          let gy = y;
          while (!this.collides({ ...piece,
              y: gy + 1
            }, this.grid)) gy++;
          this.bctx.globalAlpha = 0.25;
          for (let r = 0; r < matrix.length; r++)
            for (let c = 0; c < matrix[0].length; c++)
              if (matrix[r][c]) this.drawCell(this.bctx, (x + c) * size, (gy + r) * size, size, color);
          this.bctx.globalAlpha = 1;
        }

        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[0].length; c++) {
            if (matrix[r][c]) this.drawCell(this.bctx, (x + c) * size, (y + r) * size, size, color);
          }
        }
      }

      drawNext() {
        // Desenha miniatura da próxima peça
        this.nctx.fillStyle = '#111';
        this.nctx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
        const nextType = this.queue[0];
        if (!nextType) return;
        this.drawMini(this.nctx, SHAPES[nextType], COLORS[nextType]);
      }

      drawHold() {
        // Desenha miniatura da peça em hold
        this.hctx.fillStyle = '#111';
        this.hctx.fillRect(0, 0, this.holdCanvas.width, this.holdCanvas.height);
        if (!this.holdPiece) return;
        this.drawMini(this.hctx, SHAPES[this.holdPiece], COLORS[this.holdPiece]);
      }

      drawMini(ctx, matrix, color) {
        // Desenha miniatura centralizada
        const cell = 28;
        const offsetX = (this.nextCanvas.width - (cell * matrix[0].length)) / 2;
        const offsetY = (this.nextCanvas.height - (cell * matrix.length)) / 2;
        for (let r = 0; r < matrix.length; r++) {
          for (let c = 0; c < matrix[0].length; c++) {
            if (matrix[r][c]) this.drawCell(ctx, offsetX + c * cell, offsetY + r * cell, cell, color);
          }
        }
      }

      drawAll() {
        // Desenha tudo no tabuleiro
        this.clearBoard();
        this.drawGrid();
        if (this.active) {
          this.drawPiece(this.active, true); // Sombra
          this.drawPiece(this.active, false); // Peça ativa
        }
      }
    }


    function startGame() {
      if (game) {
        cancelAnimationFrame(game.loopId);
        document.removeEventListener("keydown", game.handleKeyDown);
      }

      game = new Game();
      document.addEventListener("keydown", game.handleKeyDown);

      // Inicia o cronômetro
      stopTimer();
      startTimer();

      // toca música ao iniciar jogo (se habilitado)
      playMusic();
    }

    Game.prototype.pauseToMenu = function() {
      cancelAnimationFrame(this.loopId);
      document.removeEventListener("keydown", this.handleKeyDown);
      stopTimer(); // Para cronômetro
      // pausa música ao ir para o menu
      pauseMusic();
      showScreen("menu");
    }


    function restartGame() {
      // Reinicia o jogo
      showScreen('jogo'); // Mostra tela do jogo
      startGame(); // Chama startGame() para reiniciar
    }

    /* Ajuste responsivo do canvas principal (mantém proporção 10x20) */
    function resizeBoard() {
      const board = document.getElementById('board');
      // Define altura máxima como 80% da tela ou 800px
      const maxH = Math.min(window.innerHeight * 0.8, 800);
      const h = Math.floor(maxH / 20) * 20; // Ajusta múltiplo de 20 linhas
      const w = Math.floor(h / 2); // Mantém proporção 10x20
      board.height = h;
      board.width = w;
      document.documentElement.style.setProperty('--cell', (w / 10) + 'px'); // Atualiza variável CSS
      if (game) game.drawAll(); // Redesenha tabuleiro se jogo ativo
    }
    window.addEventListener('resize', resizeBoard); // Chama ao redimensionar janela
    resizeBoard(); // Inicializa tamanho correto

    // Tecla ESCAPE para voltar ao login
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        const menuScreen = document.getElementById("menu");
        if (menuScreen.classList.contains("active")) { // Se estiver no menu
          showScreen("login"); // Volta para tela de login
          currentUser = null; // Limpa usuário atual
          document.getElementById("hud-username").style.display = "none"; // Esconde nome no topo
          showNotification("Você voltou para a tela de login!"); // Notificação
        }
      }
    });

    // Tecla ENTER para confirmar ações nas telas
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const cadastroAtivo = document.getElementById("cadastro").classList.contains("active");
        const loginAtivo = document.getElementById("login").classList.contains("active");
        const menuAtivo = document.getElementById("menu").classList.contains("active");

        if (cadastroAtivo) {
          cadastrar(); // Chama função de cadastro
        } else if (loginAtivo) {
          logar(); // Chama função de login
        } else if (menuAtivo) {
          startFromMenu(); // Inicia o jogo a partir do menu
        }
      }
    });
  </script>
  </body>

</html>
                      